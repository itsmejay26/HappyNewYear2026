<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Happy New Year 2026</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: Arial, sans-serif; background:#000; min-height:100vh; overflow:hidden; }
        #bg-canvas, #stars-canvas, #bg-fireworks-canvas, #fireworks-canvas {
            position:fixed; top:0; left:0; width:100%; height:100%;
        }
        #bg-canvas { z-index:0; }
        #stars-canvas { z-index:1; }
        #bg-fireworks-canvas { z-index:2; }
        #fireworks-canvas { z-index:10; }

        /* overlay for "tap anywhere to start" */
        #start-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            background: rgba(0,0,0,0.45);
            -webkit-tap-highlight-color: transparent;
        }
        #start-overlay .text {
            color: #ffffff;
            font-size: 22px;
            font-weight: 600;
            text-align: center;
            user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <canvas id="stars-canvas"></canvas>
    <canvas id="bg-fireworks-canvas"></canvas>
    <canvas id="fireworks-canvas"></canvas>

    <!-- START OVERLAY -->
    <div id="start-overlay" aria-hidden="false">
        <div class="text">tap anywhere to start</div>
    </div>

<script>
    // ==================== CONFIGURATION ====================
    const CONFIG = {
        messages: [
            "Hi Shana",
            "Happy New Yearr!",
            "I know that things didnâ€™t end how we wanted them to",
            "But I still wish you nothing but the best year ahead",
            "And nothing but good things for you",
            "I genuinely hope that this year treats you kindly",
            "And gives you peace, growth, and happiness",
            "As the year ends",
            "I just want to thank you for being everything",
            "Thank you for the memories we shared",
            "And for all the moments we were able to make together",
            "Those memories will always mean so much to me",
            "You made my life filled with happiness and love",
            "That I will forever cherish and be thankful for",
            "I also want to thank you for the memories we had",
            "And even for the memories we were hoping to make this year",
            "I just want you to know that you are the number one and most special person in my heart and in my life",
            "And that will never change",
            "No matter what happens or where life takes us",
            "You'll always have a special place with me",
            "Don't be a stranger, ha",
            "I'd still love to know how you're doing",
            "And see you doing well in life",
            "I want you to know that I'll always love you",
            "And that you're truly the sweetest person I've ever met",
            "You deserve every good thing coming your way",
            "I'll keep you in my prayers, always",
            "I love you forever and ever",
            "I hope you know I'll always support you",
            "No matter where you are in life",
            "I will never forget our memories",
            "And the time we spent together",
            "I hope you achieve your goals",
            "And continue doing what makes you happy",
            "Good luck sa journey mo in this new season of your life",
            "Again, Happy New Year",
            "Always wishing you the best - Jay"
        ],
        // Advance config:
        // type: 'fixed'  -> leadTime is used as ms (backwards-compatible)
        // type: 'relative' -> leadTime is computed as displayMs * factor, optionally clamped by min/max
        advance: {
            type: 'fixed',   // 'fixed' or 'relative'
            leadTime: 1000,   // used when type === 'fixed' (ms)
            // when type === 'relative':
            factor: 0.5,      // fraction of displayMs to use as lead (0..1)
            min: 0,           // optional clamp min ms (set null or 0 to disable)
            max: 5000         // optional clamp max ms (set null to disable)
        },

        // convenient text display min/max (ms)
        textDisplay: {
            min: 2000, // minimum time the formed text stays visible
            max: 5000  // maximum time for longest messages
        },

        stars: { count: 100, minSize: 0.3, maxSize: 1.5, twinkleSpeed: { min: 0.005, max: 0.02 }, coloredStarChance: 0.15 },

        bgFireworks: {
            spawnChance: 0.01,
            rocketSpeed: { min: 1, max: 2 },
            particleCount: 35,
            particleSpeed: { min: 0.5, max: 2.5 },
            particleSize: { min: 1, max: 2.5 },
            particleDecay: { min: 0.008, max: 0.015 },
            trailLength: 15
        },

        mainFireworks: {
            rocketSpeed: 3,
            rocketTrailLength: 20,
            particleSize: 1.8,
            particleSpacing: 3,
            explosionSpeed: { min: 5, max: 10 },
            explosionDuration: { min: 55, max: 75 },
            formingSpeed: 0.08,
            holdDuration: 10000,
            fadeSpeed: 0.012,
            fallSpeed: 0.3,
            fallAcceleration: 0.02,
            fallDrift: 0.4,
            maxRockets: 3,
            particlesPerRocket: 300
        },

        text: { maxFontSize: 38, fontSizeRatio: 12, maxWidthRatio: 0.9, lineHeightRatio: 1.4 },

        colors: { hueSpeed: { min: 2, max: 4 }, saturation: 100, lightness: 80, particleAlpha: 1 },

        delays: {
            startDelay: 1000,
            rocketLaunchInterval: 80,
            nextMessageDelay: 200,
            triggerNextAfterHoldFrames: 60,
            formSoundDelay: 0
        },

        // AUDIO config: paths/volumes
        audio: {
            enabled: true,
            // SFX sources - change to your GitHub raw URLs if you host them there
            musicSrc: 'music.mp3',        // <-- point to your raw GitHub URL or local file
            whistleSrc: 'whistle.mp3',   // launch fly sound
            popSrc: 'pop.mp3',           // particle spread
            clusterSrc: 'cluster.mp3',   // cluster after pop

            // volumes (0.0 .. 1.0)
            musicVolume: 0.3,   // background music default 30%
            sfxVolume: 1.0,     // main fireworks SFX volume
            bgSfxVolume: 0.5    // background fireworks SFX volume (50% less by default)
        }
    };

    // ==================== CANVAS SETUP ====================
    const bgCanvas = document.getElementById('bg-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const starsCanvas = document.getElementById('stars-canvas');
    const starsCtx = starsCanvas.getContext('2d');
    const bgFireworksCanvas = document.getElementById('bg-fireworks-canvas');
    const bfCtx = bgFireworksCanvas.getContext('2d');
    const fireworksCanvas = document.getElementById('fireworks-canvas');
    const fCtx = fireworksCanvas.getContext('2d');

    function resizeCanvases() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        bgCanvas.width = w; bgCanvas.height = h;
        starsCanvas.width = w; starsCanvas.height = h;
        bgFireworksCanvas.width = w; bgFireworksCanvas.height = h;
        fireworksCanvas.width = w; fireworksCanvas.height = h;
        drawBackground();
    }
    resizeCanvases();
    window.addEventListener('resize', resizeCanvases);

    function drawBackground() {
        const gradient = bgCtx.createRadialGradient(bgCanvas.width / 2, bgCanvas.height, 0, bgCanvas.width / 2, bgCanvas.height / 2, bgCanvas.height);
        gradient.addColorStop(0, '#0d1f3c');
        gradient.addColorStop(0.5, '#061224');
        gradient.addColorStop(1, '#000000');
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    }

    // ==================== STARS ====================
    class Star {
        constructor() { this.reset(); }
        reset() {
            const cfg = CONFIG.stars;
            this.x = Math.random() * starsCanvas.width;
            this.y = Math.random() * starsCanvas.height;
            this.size = Math.random() * (cfg.maxSize - cfg.minSize) + cfg.minSize;
            this.twinkleSpeed = Math.random() * (cfg.twinkleSpeed.max - cfg.twinkleSpeed.min) + cfg.twinkleSpeed.min;
            this.opacity = Math.random();
            this.twinkleDir = Math.random() > 0.5 ? 1 : -1;
            this.isColored = Math.random() < cfg.coloredStarChance;
            this.hue = Math.random() * 60 + 200;
        }
        update() {
            this.opacity += this.twinkleSpeed * this.twinkleDir;
            if (this.opacity >= 1) { this.opacity = 1; this.twinkleDir = -1; }
            if (this.opacity <= 0.2) { this.opacity = 0.2; this.twinkleDir = 1; }
        }
        draw() {
            starsCtx.beginPath();
            starsCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            if (this.isColored) starsCtx.fillStyle = `hsla(${this.hue}, 60%, 80%, ${this.opacity})`;
            else starsCtx.fillStyle = `rgba(255,255,255,${this.opacity})`;
            starsCtx.fill();
        }
    }

    const stars = [];
    for (let i = 0; i < CONFIG.stars.count; i++) stars.push(new Star());
    function animateStars() { starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height); stars.forEach(s => { s.update(); s.draw(); }); requestAnimationFrame(animateStars); }

    // ==================== BACKGROUND FIREWORKS ====================
    class BgRocket {
        constructor() {
            const cfg = CONFIG.bgFireworks;
            this.x = Math.random() * bgFireworksCanvas.width;
            this.y = bgFireworksCanvas.height + 5;
            this.targetY = Math.random() * bgFireworksCanvas.height * 0.4 + bgFireworksCanvas.height * 0.1;
            this.speed = Math.random() * (cfg.rocketSpeed.max - cfg.rocketSpeed.min) + cfg.rocketSpeed.min;
            this.trail = [];
            this.exploded = false;
            this.hue = Math.random() * 360;
            this.particlesCreated = false;
        }
        update() {
            if (this.exploded) return;
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > CONFIG.bgFireworks.trailLength) this.trail.shift();
            this.y -= this.speed;
            if (this.y <= this.targetY) this.exploded = true;
        }
        draw() {
            if (this.exploded) return;
            this.trail.forEach((t, i) => {
                const alpha = (i / this.trail.length) * 0.3;
                bfCtx.beginPath();
                bfCtx.arc(t.x, t.y, 1.2, 0, Math.PI * 2);
                bfCtx.fillStyle = `rgba(255,220,150,${alpha})`;
                bfCtx.fill();
            });
            bfCtx.beginPath();
            bfCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            bfCtx.fillStyle = '#fff';
            bfCtx.fill();
        }
    }

    class BgParticle {
        constructor(x, y, hue) {
            const cfg = CONFIG.bgFireworks;
            this.x = x; this.y = y; this.hue = hue + (Math.random() - 0.5) * 40;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (cfg.particleSpeed.max - cfg.particleSpeed.min) + cfg.particleSpeed.min;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.alpha = 0.9;
            this.decay = Math.random() * (cfg.particleDecay.max - cfg.particleDecay.min) + cfg.particleDecay.min;
            this.size = Math.random() * (cfg.particleSize.max - cfg.particleSize.min) + cfg.particleSize.min;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += 0.02; this.vx *= 0.98; this.vy *= 0.98;
            this.alpha -= this.decay;
        }
        draw() {
            if (this.alpha <= 0) return;
            bfCtx.beginPath();
            bfCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            bfCtx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.alpha * 0.6})`;
            bfCtx.fill();
        }
    }

    let bgRockets = [], bgParticles = [];
    function animateBgFireworks() {
        bfCtx.clearRect(0, 0, bgFireworksCanvas.width, bgFireworksCanvas.height);
        if (Math.random() < CONFIG.bgFireworks.spawnChance) bgRockets.push(new BgRocket());
        bgRockets.forEach(r => { r.update(); r.draw(); if (r.exploded && !r.particlesCreated) { r.particlesCreated = true; for (let i = 0; i < CONFIG.bgFireworks.particleCount; i++) bgParticles.push(new BgParticle(r.x, r.y, r.hue)); playBgExplosion(); } });
        bgRockets = bgRockets.filter(r => !r.exploded);
        bgParticles.forEach(p => { p.update(); p.draw(); });
        bgParticles = bgParticles.filter(p => p.alpha > 0);
        requestAnimationFrame(animateBgFireworks);
    }

    // ==================== MAIN TEXT FIREWORKS ====================
    // message indexing and ids:
    let globalMessageIdCounter = 0;      // generates unique ids for launched messages
    const activeMessageIdMap = {};       // map: messageIndex -> messageId
    const prelaunchedIndices = new Set();// indices already prelaunched
    let scheduledMessageIndex = null;    // index currently scheduled for display timeout
    let holdTimeout = null;

    class Particle {
        constructor(x, y, targetX, targetY, messageId) {
            const cfg = CONFIG.mainFireworks;
            const colorCfg = CONFIG.colors;
            this.x = x; this.y = y; this.targetX = targetX; this.targetY = targetY;
            this.size = cfg.particleSize; this.alpha = colorCfg.particleAlpha; this.messageId = messageId;
            this.hueOffset = Math.random() * 360;
            this.hueSpeed = Math.random() * (colorCfg.hueSpeed.max - colorCfg.hueSpeed.min) + colorCfg.hueSpeed.min;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (cfg.explosionSpeed.max - cfg.explosionSpeed.min) + cfg.explosionSpeed.min;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.phase = 'explode'; this.explodeTime = 0;
            this.maxExplodeTime = Math.random() * (cfg.explosionDuration.max - cfg.explosionDuration.min) + cfg.explosionDuration.min;
            this.holdTime = 0; this.maxHoldTime = cfg.holdDuration; this.friction = 0.97; this.isFinal = false;
            this.fallSpeedY = 0; this.fallSpeedX = (Math.random() - 0.5) * 0.5;
        }
        triggerFade() { if (this.phase === 'hold') { this.phase = 'fade'; this.fallSpeedY = 0; } }
        update() {
            const cfg = CONFIG.mainFireworks;
            this.hueOffset += this.hueSpeed; if (this.hueOffset > 360) this.hueOffset -= 360;
            if (this.phase === 'explode') {
                this.vx *= this.friction; this.vy *= this.friction; this.x += this.vx; this.y += this.vy; this.explodeTime++;
                if (this.explodeTime >= this.maxExplodeTime) this.phase = 'form';
            } else if (this.phase === 'form') {
                const dx = this.targetX - this.x; const dy = this.targetY - this.y;
                this.x += dx * cfg.formingSpeed; this.y += dy * cfg.formingSpeed;
                if (Math.abs(dx) < 0.8 && Math.abs(dy) < 0.8) { this.x = this.targetX; this.y = this.targetY; this.phase = 'hold'; this.holdTime = 0; }
            } else if (this.phase === 'hold') {
                this.x = this.targetX + (Math.random() - 0.5) * 0.3; this.y = this.targetY + (Math.random() - 0.5) * 0.3;
                this.holdTime++;
                if (!this.isFinal && this.holdTime >= this.maxHoldTime) { this.phase = 'fade'; this.fallSpeedY = 0; }
            } else if (this.phase === 'fade') {
                this.fallSpeedY += cfg.fallAcceleration;
                this.y += cfg.fallSpeed + this.fallSpeedY;
                this.x += this.fallSpeedX + (Math.random() - 0.5) * cfg.fallDrift;
                this.alpha -= cfg.fadeSpeed;
                this.size = cfg.particleSize * (0.5 + Math.random() * 0.5);
            }
        }
        draw() {
            if (this.alpha <= 0) return;
            const colorCfg = CONFIG.colors;
            const hue = this.hueOffset % 360;
            fCtx.beginPath(); fCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            fCtx.fillStyle = `hsla(${hue}, ${colorCfg.saturation}%, ${colorCfg.lightness}%, ${this.alpha})`;
            fCtx.fill();
        }
    }

    class Rocket {
        constructor(targetX, targetY, messageIndex, messageId) {
            const cfg = CONFIG.mainFireworks;
            this.x = fireworksCanvas.width / 2 + (Math.random() - 0.5) * 120;
            this.y = fireworksCanvas.height + 10;
            this.targetX = targetX; this.targetY = targetY; this.speed = cfg.rocketSpeed;
            this.trail = []; this.exploded = false; this.particlesCreated = false;
            this.messageIndex = messageIndex;
            this.messageId = messageId;
            const dx = this.targetX - this.x; const dy = this.targetY - this.y; const dist = Math.sqrt(dx * dx + dy * dy);
            this.vx = (dx / dist) * this.speed; this.vy = (dy / dist) * this.speed;
        }
        update() {
            if (this.exploded) return;
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > CONFIG.mainFireworks.rocketTrailLength) this.trail.shift();
            this.x += this.vx; this.y += this.vy;
            const dx = this.targetX - this.x; const dy = this.targetY - this.y;
            if (Math.sqrt(dx * dx + dy * dy) < 10) this.exploded = true;
        }
        draw() {
            if (this.exploded) return;
            this.trail.forEach((t, i) => {
                const alpha = (i / this.trail.length) * 0.5;
                fCtx.beginPath(); fCtx.arc(t.x, t.y, 1, 0, Math.PI * 2);
                fCtx.fillStyle = `rgba(255,240,200,${alpha})`; fCtx.fill();
            });
            fCtx.beginPath(); fCtx.arc(this.x, this.y, 2, 0, Math.PI * 2); fCtx.fillStyle = '#fff'; fCtx.fill();
        }
    }

    let particles = [], rockets = [];
    let currentMessageIndex = 0;
    let isShowingMessage = false, canLaunchNext = true;
    let formSoundPlayed = false;

    // ==================== TEXT HELPERS ====================
    function wrapText(ctx, text, maxWidth) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        words.forEach(word => {
            const testLine = currentLine ? currentLine + ' ' + word : word;
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = testLine;
            }
        });
        if (currentLine) lines.push(currentLine);
        return lines;
    }

    function getTextParticles(text, centerX, centerY) {
        const cfg = CONFIG.text;
        const mainCfg = CONFIG.mainFireworks;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        const maxWidth = fireworksCanvas.width * cfg.maxWidthRatio;
        let fontSize = Math.min(cfg.maxFontSize, fireworksCanvas.width / cfg.fontSizeRatio);
        tempCtx.font = `bold ${fontSize}px Arial`;
        const lines = wrapText(tempCtx, text, maxWidth);
        const lineHeight = fontSize * cfg.lineHeightRatio;
        const totalHeight = lines.length * lineHeight;
        let maxLineWidth = 0;
        lines.forEach(line => { const w = tempCtx.measureText(line).width; if (w > maxLineWidth) maxLineWidth = w; });
        tempCanvas.width = Math.max(maxLineWidth + 30, 100);
        tempCanvas.height = Math.max(totalHeight + 30, 50);
        tempCtx.font = `bold ${fontSize}px Arial`;
        tempCtx.fillStyle = '#fff';
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        lines.forEach((line, i) => {
            const y = (i + 0.5) * lineHeight + 15;
            tempCtx.fillText(line, tempCanvas.width / 2, y);
        });
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const positions = [];
        const spacing = mainCfg.particleSpacing;
        for (let y = 0; y < tempCanvas.height; y += spacing) {
            for (let x = 0; x < tempCanvas.width; x += spacing) {
                const i = (y * tempCanvas.width + x) * 4;
                if (imageData.data[i + 3] > 128) {
                    positions.push({ x: x - tempCanvas.width / 2 + centerX, y: y - tempCanvas.height / 2 + centerY });
                }
            }
        }
        return positions;
    }

    function clearHoldTimer() {
        if (holdTimeout) { clearTimeout(holdTimeout); holdTimeout = null; scheduledMessageIndex = null; }
    }

    function triggerCurrentMessageFade() {
        clearHoldTimer();
        const activeId = activeMessageIdMap[currentMessageIndex];
        particles.forEach(p => {
            if (p.messageId === activeId && !p.isFinal) {
                p.triggerFade();
            }
        });
    }

    // Launch fireworks for a specific message index.
    function launchFireworksForIndex(index, isFinal) {
        const cfg = CONFIG.mainFireworks;
        const delayCfg = CONFIG.delays;
        const centerX = fireworksCanvas.width / 2;
        const centerY = fireworksCanvas.height / 2;
        const text = CONFIG.messages[index];
        const textPositions = getTextParticles(text, centerX, centerY);

        if (textPositions.length === 0) {
            console.log('No positions found for index:', index, text);
            // schedule proceed for next (safe skip)
            setTimeout(() => { safeProceedFromIndex(index); }, 500);
            return;
        }

        // create unique messageId for this index if not already created
        if (!activeMessageIdMap.hasOwnProperty(index)) {
            globalMessageIdCounter++;
            activeMessageIdMap[index] = globalMessageIdCounter;
        }
        const messageId = activeMessageIdMap[index];

        const rocketCount = Math.min(cfg.maxRockets, Math.max(1, Math.ceil(textPositions.length / cfg.particlesPerRocket)));
        const rocketTargets = [];
        for (let i = 0; i < rocketCount; i++) {
            const offsetX = (i - (rocketCount - 1) / 2) * 50;
            rocketTargets.push({ x: centerX + offsetX, y: centerY });
        }
        const particlesPerRocket = Math.ceil(textPositions.length / rocketCount);

        // mark as prelaunched if index is not current
        if (index !== currentMessageIndex) prelaunchedIndices.add(index);

        // set flags (only set isShowing/canLaunchNext when this is the active current index)
        if (index === currentMessageIndex) {
            isShowingMessage = true;
            canLaunchNext = false;
            formSoundPlayed = false;
        }

        rocketTargets.forEach((target, idx) => {
            setTimeout(() => {
                playLaunchSound();
                const rocket = new Rocket(target.x, target.y, index, messageId);
                rocket.particleStart = idx * particlesPerRocket;
                rocket.particleEnd = Math.min((idx + 1) * particlesPerRocket, textPositions.length);
                rocket.textPositions = textPositions;
                rocket.isFinal = isFinal;
                rocket.messageId = messageId;
                rockets.push(rocket);
            }, idx * delayCfg.rocketLaunchInterval);
        });

        // fallback: if this launched message stalls (no particles or fade) - proceed safely
        setTimeout(() => {
            // only act if this message id is still the latest assigned for that index
            const currentAssignedId = activeMessageIdMap[index];
            const currentParticles = particles.filter(p => p.messageId === currentAssignedId);
            const stalled = currentParticles.length === 0 || currentParticles.every(p => p.phase === 'fade' || p.alpha <= 0);
            if (stalled) {
                console.log('Fallback for index', index, '-> forcing safe proceed');
                safeProceedFromIndex(index);
            }
        }, 7000);
    }

    function safeProceedFromIndex(index) {
        if (index === currentMessageIndex) {
            proceedToNextMessage();
        } else {
            prelaunchedIndices.delete(index);
        }
    }

    function createParticles(rocket) {
        playExplosionSound();
        for (let i = rocket.particleStart; i < rocket.particleEnd; i++) {
            const pos = rocket.textPositions[i];
            const p = new Particle(rocket.x, rocket.y, pos.x, pos.y, rocket.messageId);
            p.isFinal = rocket.isFinal;
            particles.push(p);
        }
    }

    function proceedToNextMessage() {
        clearHoldTimer();
        triggerCurrentMessageFade();
        const nextIndex = currentMessageIndex + 1;
        currentMessageIndex = nextIndex;

        if (currentMessageIndex < CONFIG.messages.length) {
            const isFinal = currentMessageIndex === CONFIG.messages.length - 1;

            if (prelaunchedIndices.has(currentMessageIndex)) {
                isShowingMessage = true;
                canLaunchNext = false;
                formSoundPlayed = false;
                prelaunchedIndices.delete(currentMessageIndex);
            } else {
                setTimeout(() => {
                    formSoundPlayed = false;
                    launchFireworksForIndex(currentMessageIndex, isFinal);
                }, CONFIG.delays.nextMessageDelay);
            }
        }
    }

    // ==================== AUDIO (replaced with real sample-based SFX + music) ====================
    let audioStarted = false;
    let musicAudio = null;
    const sfxPool = { whistle: CONFIG.audio.whistleSrc, pop: CONFIG.audio.popSrc, cluster: CONFIG.audio.clusterSrc };

    function createAudioElement(src, loop = false) {
        try {
            const a = new Audio(src);
            a.loop = !!loop;
            a.preload = 'auto';
            a.crossOrigin = "anonymous";
            return a;
        } catch (e) {
            console.warn('Audio creation failed for', src, e);
            return null;
        }
    }

    async function initAudio() {
        if (audioStarted || !CONFIG.audio.enabled) return;
        try {
            // set flag early to avoid double-init
            audioStarted = true;

            // music element
            musicAudio = createAudioElement(CONFIG.audio.musicSrc, true);
            if (musicAudio) {
                musicAudio.volume = clampVolume(CONFIG.audio.musicVolume);
                musicAudio.loop = true;
                // start only after first user gesture (handled by start sequence)
            }

            // preload sfx (we will clone for overlapping)
            // create single instances to warm up the browser
            if (CONFIG.audio.whistleSrc) {
                const pre = createAudioElement(CONFIG.audio.whistleSrc);
                if (pre) { pre.volume = clampVolume(CONFIG.audio.sfxVolume); pre.muted = true; pre.play().catch(()=>{}); setTimeout(()=>{ pre.pause(); pre.currentTime = 0; pre.muted = false; }, 200); }
            }
            if (CONFIG.audio.popSrc) {
                const pre = createAudioElement(CONFIG.audio.popSrc);
                if (pre) { pre.volume = clampVolume(CONFIG.audio.sfxVolume); pre.muted = true; pre.play().catch(()=>{}); setTimeout(()=>{ pre.pause(); pre.currentTime = 0; pre.muted = false; }, 200); }
            }
            if (CONFIG.audio.clusterSrc) {
                const pre = createAudioElement(CONFIG.audio.clusterSrc);
                if (pre) { pre.volume = clampVolume(CONFIG.audio.sfxVolume); pre.muted = true; pre.play().catch(()=>{}); setTimeout(()=>{ pre.pause(); pre.currentTime = 0; pre.muted = false; }, 200); }
            }

            // Note: we are not using Tone.js synths for launch/explosion SFX anymore.
            // music playback will be started by start() (after user gesture), since many browsers block auto-play.

        } catch (e) {
            console.log('Audio init failed:', e);
        }
    }

    function clampVolume(v) {
        if (typeof v !== 'number') return 1.0;
        return Math.max(0, Math.min(1, v));
    }

    // Helper to play a cloned audio so overlapping is allowed
    function playSample(src, volume = 1.0) {
        if (!CONFIG.audio.enabled || !audioStarted || !src) return;
        try {
            const a = new Audio(src);
            a.crossOrigin = "anonymous";
            a.volume = clampVolume(volume);
            a.preload = 'auto';
            a.play().catch((e)=>{ /* may fail depending on gesture */ });
            // no need to keep reference; let the element be GC'd after playback
        } catch (e) {
            console.warn('playSample error', e);
        }
    }

    // Replace previous Tone-based sound calls with sample playback
    function playLaunchSound() {
        if (!CONFIG.audio.enabled || !audioStarted) return;
        // whistle = rocket fly sound
        const volume = CONFIG.audio.sfxVolume;
        playSample(CONFIG.audio.whistleSrc, volume);
    }

    function playExplosionSound() {
        if (!CONFIG.audio.enabled || !audioStarted) return;
        // pop then cluster
        const vol = CONFIG.audio.sfxVolume;
        playSample(CONFIG.audio.popSrc, vol);
        // small delay then cluster
        setTimeout(() => {
            playSample(CONFIG.audio.clusterSrc, vol * 0.9);
        }, 90);
    }

    function playBgExplosion() {
        if (!CONFIG.audio.enabled || !audioStarted) return;
        // background fireworks are quieter (bgSfxVolume)
        const bgVol = CONFIG.audio.sfxVolume * clampVolume(CONFIG.audio.bgSfxVolume);
        playSample(CONFIG.audio.popSrc, bgVol);
    }

    function playFormSound() {
        // keep this quiet or use a subtle sample; for now, we use a very soft pop to mark form completion
        if (!CONFIG.audio.enabled || !audioStarted) return;
        const vol = CONFIG.audio.sfxVolume * 0.6;
        // use cluster as a soft accent (or pop if cluster not present)
        const src = CONFIG.audio.clusterSrc || CONFIG.audio.popSrc;
        playSample(src, vol);
    }

    // ==================== ANIMATION LOOP ====================
    function checkAllFormedForCurrent() {
        const activeId = activeMessageIdMap[currentMessageIndex];
        if (!activeId) return false;
        const currentParticles = particles.filter(p => p.messageId === activeId);
        if (currentParticles.length === 0) return false;
        return currentParticles.every(p => p.phase === 'hold' || p.phase === 'fade');
    }

    // compute leadTime depending on CONFIG.advance settings and displayMs
    function computeLead(displayMs) {
        const adv = CONFIG.advance || {};
        if (adv.type === 'relative') {
            let factor = (typeof adv.factor === 'number') ? adv.factor : 0.5;
            factor = Math.max(0, Math.min(1, factor));
            let lead = Math.round(displayMs * factor);
            if (typeof adv.min === 'number') lead = Math.max(lead, adv.min);
            if (typeof adv.max === 'number') lead = Math.min(lead, adv.max);
            return Math.max(0, lead);
        } else {
            // fixed
            return Math.max(0, adv.leadTime || 0);
        }
    }

    function animate() {
        fCtx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);

        rockets.forEach(rocket => {
            rocket.update(); rocket.draw();
            if (rocket.exploded && !rocket.particlesCreated) {
                rocket.particlesCreated = true;
                createParticles(rocket);
            }
        });
        rockets = rockets.filter(r => !r.exploded);

        particles.forEach(p => { p.update(); p.draw(); });

        // Play form sound when all particles for current message are formed
        if (!formSoundPlayed && checkAllFormedForCurrent() && particles.length > 0) {
            formSoundPlayed = true;
            setTimeout(() => { playFormSound(); }, CONFIG.delays.formSoundDelay);

            // SCHEDULE display timeout when text has formed
            if (scheduledMessageIndex !== currentMessageIndex) {
                const text = CONFIG.messages[currentMessageIndex] || "";
                const chars = text.length || 0;
                const ratio = Math.min(1, chars / 80);
                const displayMs = CONFIG.textDisplay.min + Math.round(ratio * (CONFIG.textDisplay.max - CONFIG.textDisplay.min));

                // schedule prelaunch of next message depending on advance settings
                const nextIndex = currentMessageIndex + 1;
                if (nextIndex < CONFIG.messages.length) {
                    const lead = computeLead(displayMs); // NEW: computed from displayMs when type === 'relative'
                    const prelaunchDelay = Math.max(0, displayMs - lead);
                    setTimeout(() => {
                        if (!activeMessageIdMap.hasOwnProperty(nextIndex)) {
                            const isFinalNext = nextIndex === CONFIG.messages.length - 1;
                            launchFireworksForIndex(nextIndex, isFinalNext);
                        }
                    }, prelaunchDelay);
                }

                // schedule actual proceed (fade + switch) at displayMs
                scheduledMessageIndex = currentMessageIndex;
                clearHoldTimer();
                holdTimeout = setTimeout(() => {
                    canLaunchNext = true;
                    proceedToNextMessage();
                    scheduledMessageIndex = null;
                    holdTimeout = null;
                }, displayMs);
            }
        }

        // Clean up dead particles (but keep final ones)
        particles = particles.filter(p => p.alpha > 0 || p.isFinal);

        requestAnimationFrame(animate);
    }

    // ==================== START (only after user tap) ====================
    async function start() {
        // initialize audio (preload etc.)
        await initAudio();

        // start music if available
        if (musicAudio) {
            try {
                // ensure music starts from beginning
                musicAudio.currentTime = 0;
                musicAudio.play().catch((e)=>{ /* play may be blocked if not a user gesture; start() is triggered by gesture */ });
            } catch (e) {
                console.warn('music play failed', e);
            }
        }

        // then schedule first fireworks (respect startDelay)
        setTimeout(() => { launchFireworksForIndex(0, CONFIG.messages.length === 1); }, CONFIG.delays.startDelay);
    }

    animateStars();
    animateBgFireworks();
    animate();

    // previously the script auto-started on DOMContentLoaded;
    // now we show a "tap anywhere to start" overlay and start everything on first user tap/click.

    const overlay = document.getElementById('start-overlay');
    function onStartGesture(e) {
        // hide overlay
        if (overlay) {
            overlay.style.display = 'none';
            overlay.setAttribute('aria-hidden', 'true');
        }
        // mark audio ready and start everything
        initAudio().then(() => {
            // ensure audioStarted true
            audioStarted = true;
            // start background music and animations/messages
            start();
        });

        // remove listeners after first activation
        document.removeEventListener('pointerdown', onStartGesture);
        document.removeEventListener('touchstart', onStartGesture);
        document.removeEventListener('click', onStartGesture);
    }

    // Accept pointerdown/touchstart/click for broader device support.
    document.addEventListener('pointerdown', onStartGesture, { once: true });
    document.addEventListener('touchstart', onStartGesture, { once: true });
    document.addEventListener('click', onStartGesture, { once: true });

    // also ensure overlay can be tapped (some devices may not bubble pointerdown)
    overlay.addEventListener('pointerdown', onStartGesture, { once: true });
    overlay.addEventListener('touchstart', onStartGesture, { once: true });
    overlay.addEventListener('click', onStartGesture, { once: true });

    // ensure initAudio is at least prepared on interaction
    document.body.addEventListener('touchstart', () => { initAudio(); }, { once: true });
    document.body.addEventListener('click', () => { initAudio(); }, { once: true });
</script>
</body>
</html>
