
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy New Year 2026</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            min-height: 100vh;
            overflow: hidden;
        }

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #stars-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #bg-fireworks-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #fireworks-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <canvas id="stars-canvas"></canvas>
    <canvas id="bg-fireworks-canvas"></canvas>
    <canvas id="fireworks-canvas"></canvas>
    <div id="progress"></div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            // Messages to display - ALL 37 MESSAGES
            messages: [
                "Hi Shana",
                "Happy New Year!",
                "I know that things didn't end how we wanted them to",
                "But I still wish you nothing but the best year ahead",
                "And nothing but good things for you",
                "I genuinely hope that this year treats you kindly",
                "And gives you peace, growth, and happiness",
                "As the year ends",
                "I just want to thank you for being everything",
                "Thank you for the memories we shared",
                "And for all the moments we were able to make together",
                "Those memories will always mean so much to me",
                "You made my life filled with happiness and love",
                "That I will forever cherish and be thankful for",
                "I also want to thank you for the memories we had",
                "And even for the memories we were hoping to make this year",
                "I just want you to know that you are the number one and most special person in my heart and in my life",
                "And that will never change",
                "No matter what happens or where life takes us",
                "You'll always have a special place with me",
                "Don't be a stranger, ha",
                "I'd still love to know how you're doing",
                "And see you doing well in life",
                "I want you to know that I'll always love you",
                "And that you're truly the sweetest person I've ever met",
                "You deserve every good thing coming your way",
                "I'll keep you in my prayers, always",
                "I love you forever and ever",
                "I hope you know I'll always support you",
                "No matter where you are in life",
                "I will never forget our memories",
                "And the time we spent together",
                "I hope you achieve your goals",
                "And continue doing what makes you happy",
                "Good luck sa journey mo in this new season of your life",
                "Again, Happy New Year",
                "Always wishing you the best"
            ],

            // Stars configuration
            stars: {
                count: 100,
                minSize: 0.3,
                maxSize: 1.5,
                twinkleSpeed: { min: 0.005, max: 0.02 },
                coloredStarChance: 0.15
            },

            // Background fireworks configuration
            bgFireworks: {
                spawnChance: 0.01,
                rocketSpeed: { min: 1, max: 2 },
                particleCount: 35,
                particleSpeed: { min: 0.5, max: 2.5 },
                particleSize: { min: 1, max: 2.5 },
                particleDecay: { min: 0.008, max: 0.015 },
                trailLength: 15
            },

            // Main text fireworks configuration
            mainFireworks: {
                rocketSpeed: 4,
                rocketTrailLength: 20,
                particleSize: 2,
                particleSpacing: 4,
                explosionSpeed: { min: 5, max: 10 },
                explosionDuration: { min: 45, max: 65 },
                formingSpeed: 0.1,
                holdDuration: 80,
                fadeSpeed: 0.015,
                fallSpeed: 0.3,
                fallAcceleration: 0.025,
                fallDrift: 0.4,
                maxRockets: 2,
                particlesPerRocket: 250
            },

            // Text configuration
            text: {
                maxFontSize: 32,
                minFontSize: 18,
                fontSizeRatio: 14,
                maxWidthRatio: 0.92,
                lineHeightRatio: 1.35
            },

            // Color configuration
            colors: {
                hueSpeed: { min: 2, max: 4 },
                saturation: 100,
                lightness: 80,
                particleAlpha: 1
            },

            // Delay & Timing configuration
            delays: {
                startDelay: 1000,
                rocketLaunchInterval: 60,
                nextMessageDelay: 150,
                triggerNextAfterHoldFrames: 50,
                formSoundDelay: 0
            },

            // Audio configuration
            audio: {
                enabled: true,
                synthVolume: -18,
                bassVolume: -12,
                noiseVolume: -22,
                bgNoiseVolume: -38,
                padVolume: -26,
                chordInterval: 6000
            },

            // Show progress indicator
            showProgress: true
        };

        // ==================== CANVAS SETUP ====================
        const bgCanvas = document.getElementById('bg-canvas');
        const bgCtx = bgCanvas.getContext('2d');
        const starsCanvas = document.getElementById('stars-canvas');
        const starsCtx = starsCanvas.getContext('2d');
        const bgFireworksCanvas = document.getElementById('bg-fireworks-canvas');
        const bfCtx = bgFireworksCanvas.getContext('2d');
        const fireworksCanvas = document.getElementById('fireworks-canvas');
        const fCtx = fireworksCanvas.getContext('2d');
        const progressEl = document.getElementById('progress');

        function resizeCanvases() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            bgCanvas.width = w;
            bgCanvas.height = h;
            starsCanvas.width = w;
            starsCanvas.height = h;
            bgFireworksCanvas.width = w;
            bgFireworksCanvas.height = h;
            fireworksCanvas.width = w;
            fireworksCanvas.height = h;
            drawBackground();
        }

        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        function drawBackground() {
            const gradient = bgCtx.createRadialGradient(
                bgCanvas.width / 2, bgCanvas.height, 0,
                bgCanvas.width / 2, bgCanvas.height / 2, bgCanvas.height
            );
            gradient.addColorStop(0, '#0d1f3c');
            gradient.addColorStop(0.5, '#061224');
            gradient.addColorStop(1, '#000000');
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        }

        drawBackground();

        function updateProgress(current, total) {
            if (CONFIG.showProgress) {
                progressEl.textContent = `${current + 1} / ${total}`;
            }
        }

        // ==================== STARS ====================
        class Star {
            constructor() {
                this.reset();
            }

            reset() {
                const cfg = CONFIG.stars;
                this.x = Math.random() * starsCanvas.width;
                this.y = Math.random() * starsCanvas.height;
                this.size = Math.random() * (cfg.maxSize - cfg.minSize) + cfg.minSize;
                this.twinkleSpeed = Math.random() * (cfg.twinkleSpeed.max - cfg.twinkleSpeed.min) + cfg.twinkleSpeed.min;
                this.opacity = Math.random();
                this.twinkleDir = Math.random() > 0.5 ? 1 : -1;
                this.isColored = Math.random() < cfg.coloredStarChance;
                this.hue = Math.random() * 60 + 200;
            }

            update() {
                this.opacity += this.twinkleSpeed * this.twinkleDir;
                if (this.opacity >= 1) { this.opacity = 1; this.twinkleDir = -1; }
                if (this.opacity <= 0.2) { this.opacity = 0.2; this.twinkleDir = 1; }
            }

            draw() {
                starsCtx.beginPath();
                starsCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                if (this.isColored) {
                    starsCtx.fillStyle = `hsla(${this.hue}, 60%, 80%, ${this.opacity})`;
                } else {
                    starsCtx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                }
                starsCtx.fill();
            }
        }

        const stars = [];
        for (let i = 0; i < CONFIG.stars.count; i++) stars.push(new Star());

        function animateStars() {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
            stars.forEach(s => { s.update(); s.draw(); });
            requestAnimationFrame(animateStars);
        }

        // ==================== BACKGROUND FIREWORKS ====================
        class BgRocket {
            constructor() {
                const cfg = CONFIG.bgFireworks;
                this.x = Math.random() * bgFireworksCanvas.width;
                this.y = bgFireworksCanvas.height + 5;
                this.targetY = Math.random() * bgFireworksCanvas.height * 0.4 + bgFireworksCanvas.height * 0.1;
                this.speed = Math.random() * (cfg.rocketSpeed.max - cfg.rocketSpeed.min) + cfg.rocketSpeed.min;
                this.trail = [];
                this.exploded = false;
                this.hue = Math.random() * 360;
                this.particlesCreated = false;
            }

            update() {
                if (this.exploded) return;
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > CONFIG.bgFireworks.trailLength) this.trail.shift();
                this.y -= this.speed;
                if (this.y <= this.targetY) this.exploded = true;
            }

            draw() {
                if (this.exploded) return;
                this.trail.forEach((t, i) => {
                    const alpha = (i / this.trail.length) * 0.3;
                    bfCtx.beginPath();
                    bfCtx.arc(t.x, t.y, 1.2, 0, Math.PI * 2);
                    bfCtx.fillStyle = `rgba(255, 220, 150, ${alpha})`;
                    bfCtx.fill();
                });
                bfCtx.beginPath();
                bfCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                bfCtx.fillStyle = '#fff';
                bfCtx.fill();
            }
        }

        class BgParticle {
            constructor(x, y, hue) {
                const cfg = CONFIG.bgFireworks;
                this.x = x;
                this.y = y;
                this.hue = hue + (Math.random() - 0.5) * 40;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (cfg.particleSpeed.max - cfg.particleSpeed.min) + cfg.particleSpeed.min;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.alpha = 0.9;
                this.decay = Math.random() * (cfg.particleDecay.max - cfg.particleDecay.min) + cfg.particleDecay.min;
                this.size = Math.random() * (cfg.particleSize.max - cfg.particleSize.min) + cfg.particleSize.min;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.02;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.alpha -= this.decay;
            }

            draw() {
                if (this.alpha <= 0) return;
                bfCtx.beginPath();
                bfCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                bfCtx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${this.alpha * 0.6})`;
                bfCtx.fill();
            }
        }

        let bgRockets = [];
        let bgParticles = [];

        function animateBgFireworks() {
            bfCtx.clearRect(0, 0, bgFireworksCanvas.width, bgFireworksCanvas.height);

            if (Math.random() < CONFIG.bgFireworks.spawnChance) {
                bgRockets.push(new BgRocket());
            }

            bgRockets.forEach(r => {
                r.update();
                r.draw();
                if (r.exploded && !r.particlesCreated) {
                    r.particlesCreated = true;
                    for (let i = 0; i < CONFIG.bgFireworks.particleCount; i++) {
                        bgParticles.push(new BgParticle(r.x, r.y, r.hue));
                    }
                    playBgExplosion();
                }
            });
            bgRockets = bgRockets.filter(r => !r.exploded);

            bgParticles.forEach(p => { p.update(); p.draw(); });
            bgParticles = bgParticles.filter(p => p.alpha > 0);

            requestAnimationFrame(animateBgFireworks);
        }

        // ==================== MAIN TEXT FIREWORKS ====================
        class Particle {
            constructor(x, y, targetX, targetY, messageId) {
                const cfg = CONFIG.mainFireworks;
                const colorCfg = CONFIG.colors;
                
                this.x = x;
                this.y = y;
                this.targetX = targetX;
                this.targetY = targetY;
                this.size = cfg.particleSize;
                this.alpha = colorCfg.particleAlpha;
                this.messageId = messageId;
                
                this.hueOffset = Math.random() * 360;
                this.hueSpeed = Math.random() * (colorCfg.hueSpeed.max - colorCfg.hueSpeed.min) + colorCfg.hueSpeed.min;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (cfg.explosionSpeed.max - cfg.explosionSpeed.min) + cfg.explosionSpeed.min;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.phase = 'explode';
                this.explodeTime = 0;
                this.maxExplodeTime = Math.random() * (cfg.explosionDuration.max - cfg.explosionDuration.min) + cfg.explosionDuration.min;
                this.holdTime = 0;
                this.maxHoldTime = cfg.holdDuration;
                this.friction = 0.97;
                this.isFinal = false;
                
                this.fallSpeedY = 0;
                this.fallSpeedX = (Math.random() - 0.5) * 0.5;
            }

            triggerFade() {
                if (this.phase === 'hold' || this.phase === 'form') {
                    this.phase = 'fade';
                    this.fallSpeedY = 0;
                }
            }

            update() {
                const cfg = CONFIG.mainFireworks;
                
                this.hueOffset += this.hueSpeed;
                if (this.hueOffset > 360) this.hueOffset -= 360;
                
                if (this.phase === 'explode') {
                    this.vx *= this.friction;
                    this.vy *= this.friction;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.explodeTime++;
                    
                    if (this.explodeTime >= this.maxExplodeTime) {
                        this.phase = 'form';
                    }
                } else if (this.phase === 'form') {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    this.x += dx * cfg.formingSpeed;
                    this.y += dy * cfg.formingSpeed;
                    
                    if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.phase = 'hold';
                        this.holdTime = 0;
                    }
                } else if (this.phase === 'hold') {
                    this.x = this.targetX + (Math.random() - 0.5) * 0.3;
                    this.y = this.targetY + (Math.random() - 0.5) * 0.3;
                    this.holdTime++;
                    
                    if (!this.isFinal && this.holdTime >= this.maxHoldTime) {
                        this.phase = 'fade';
                        this.fallSpeedY = 0;
                    }
                } else if (this.phase === 'fade') {
                    this.fallSpeedY += cfg.fallAcceleration;
                    this.y += cfg.fallSpeed + this.fallSpeedY;
                    this.x += this.fallSpeedX + (Math.random() - 0.5) * cfg.fallDrift;
                    this.alpha -= cfg.fadeSpeed;
                    this.size = cfg.particleSize * (0.5 + Math.random() * 0.5);
                }
            }

            draw() {
                if (this.alpha <= 0) return;
                const colorCfg = CONFIG.colors;
                const hue = this.hueOffset % 360;
                
                fCtx.beginPath();
                fCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                fCtx.fillStyle = `hsla(${hue}, ${colorCfg.saturation}%, ${colorCfg.lightness}%, ${this.alpha})`;
                fCtx.fill();
            }
        }

        class Rocket {
            constructor(targetX, targetY) {
                const cfg = CONFIG.mainFireworks;
                
                this.x = fireworksCanvas.width / 2 + (Math.random() - 0.5) * 100;
                this.y = fireworksCanvas.height + 10;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = cfg.rocketSpeed;
                this.trail = [];
                this.exploded = false;
                this.particlesCreated = false;
                
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / dist) * this.speed;
                this.vy = (dy / dist) * this.speed;
            }

            update() {
                if (this.exploded) return;
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > CONFIG.mainFireworks.rocketTrailLength) this.trail.shift();
                this.x += this.vx;
                this.y += this.vy;
                
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                if (Math.sqrt(dx * dx + dy * dy) < 10) {
                    this.exploded = true;
                }
            }

            draw() {
                if (this.exploded) return;
                this.trail.forEach((t, i) => {
                    const alpha = (i / this.trail.length) * 0.5;
                    fCtx.beginPath();
                    fCtx.arc(t.x, t.y, 1, 0, Math.PI * 2);
                    fCtx.fillStyle = `rgba(255, 240, 200, ${alpha})`;
                    fCtx.fill();
                });
                fCtx.beginPath();
                fCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                fCtx.fillStyle = '#fff';
                fCtx.fill();
            }
        }

        let particles = [];
        let rockets = [];
        let currentMessageIndex = 0;
        let currentMessageId = 0;
        let isShowingMessage = false;
        let canLaunchNext = true;
        let holdFrameCount = 0;
        let formSoundPlayed = false;
        let isLaunching = false;

        // ==================== TEXT HELPERS ====================
        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) lines.push(currentLine);
            return lines;
        }

        function getTextParticles(text, centerX, centerY) {
            const cfg = CONFIG.text;
            const mainCfg = CONFIG.mainFireworks;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const maxWidth = fireworksCanvas.width * cfg.maxWidthRatio;
            
            // Calculate dynamic font size based on text length
            let fontSize = Math.min(cfg.maxFontSize, fireworksCanvas.width / cfg.fontSizeRatio);
            if (text.length > 50) {
                fontSize = Math.max(cfg.minFontSize, fontSize * 0.8);
            }
            if (text.length > 80) {
                fontSize = Math.max(cfg.minFontSize, fontSize * 0.85);
            }
            
            tempCtx.font = `bold ${fontSize}px Arial`;
            const lines = wrapText(tempCtx, text, maxWidth);
            
            const lineHeight = fontSize * cfg.lineHeightRatio;
            const totalHeight = lines.length * lineHeight;
            
            let maxLineWidth = 0;
            lines.forEach(line => {
                const w = tempCtx.measureText(line).width;
                if (w > maxLineWidth) maxLineWidth = w;
            });
            
            tempCanvas.width = Math.max(maxLineWidth + 40, 100);
            tempCanvas.height = Math.max(totalHeight + 40, 60);
            
            tempCtx.font = `bold ${fontSize}px Arial`;
            tempCtx.fillStyle = '#fff';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            
            lines.forEach((line, i) => {
                const y = (i + 0.5) * lineHeight + 20;
                tempCtx.fillText(line, tempCanvas.width / 2, y);
            });
            
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const positions = [];
            const spacing = mainCfg.particleSpacing;
            
            for (let y = 0; y < tempCanvas.height; y += spacing) {
                for (let x = 0; x < tempCanvas.width; x += spacing) {
                    const i = (y * tempCanvas.width + x) * 4;
                    if (imageData.data[i + 3] > 128) {
                        positions.push({
                            x: x - tempCanvas.width / 2 + centerX,
                            y: y - tempCanvas.height / 2 + centerY
                        });
                    }
                }
            }
            
            return positions;
        }

        function triggerCurrentMessageFade() {
            particles.forEach(p => {
                if (!p.isFinal) {
                    p.triggerFade();
                }
            });
        }

        function launchFireworks(text, isFinal) {
            if (isLaunching) return;
            isLaunching = true;
            
            const cfg = CONFIG.mainFireworks;
            const delayCfg = CONFIG.delays;
            
            const centerX = fireworksCanvas.width / 2;
            const centerY = fireworksCanvas.height / 2;
            
            const textPositions = getTextParticles(text, centerX, centerY);
            
            updateProgress(currentMessageIndex, CONFIG.messages.length);
            
            if (textPositions.length === 0) {
                console.log('No positions for:', text);
                isLaunching = false;
                setTimeout(() => proceedToNextMessage(), 100);
                return;
            }
            
            currentMessageId++;
            const messageId = currentMessageId;
            
            const rocketCount = Math.min(cfg.maxRockets, Math.max(1, Math.ceil(textPositions.length / cfg.particlesPerRocket)));
            
            const rocketTargets = [];
            for (let i = 0; i < rocketCount; i++) {
                const offsetX = (i - (rocketCount - 1) / 2) * 40;
                rocketTargets.push({ x: centerX + offsetX, y: centerY });
            }
            
            const particlesPerRocket = Math.ceil(textPositions.length / rocketCount);
            
            isShowingMessage = true;
            canLaunchNext = false;
            holdFrameCount = 0;
            formSoundPlayed = false;
            
            let launchedCount = 0;
            rocketTargets.forEach((target, idx) => {
                setTimeout(() => {
                    playLaunchSound();
                    const rocket = new Rocket(target.x, target.y);
                    rocket.particleStart = idx * particlesPerRocket;
                    rocket.particleEnd = Math.min((idx + 1) * particlesPerRocket, textPositions.length);
                    rocket.textPositions = textPositions;
                    rocket.isFinal = isFinal;
                    rocket.messageId = messageId;
                    rockets.push(rocket);
                    launchedCount++;
                    if (launchedCount >= rocketCount) {
                        isLaunching = false;
                    }
                }, idx * delayCfg.rocketLaunchInterval);
            });
        }

        function createParticles(rocket) {
            playExplosionSound();
            
            for (let i = rocket.particleStart; i < rocket.particleEnd; i++) {
                const pos = rocket.textPositions[i];
                const p = new Particle(rocket.x, rocket.y, pos.x, pos.y, rocket.messageId);
                p.isFinal = rocket.isFinal;
                particles.push(p);
            }
        }

        function proceedToNextMessage() {
            if (isLaunching) return;
            
            currentMessageIndex++;
            
            if (currentMessageIndex < CONFIG.messages.length) {
                const isFinal = currentMessageIndex === CONFIG.messages.length - 1;
                
                triggerCurrentMessageFade();
                
                setTimeout(() => {
                    formSoundPlayed = false;
                    launchFireworks(CONFIG.messages[currentMessageIndex], isFinal);
                }, CONFIG.delays.nextMessageDelay);
            } else {
                // All messages done
                updateProgress(CONFIG.messages.length - 1, CONFIG.messages.length);
            }
        }

        // ==================== AUDIO ====================
        let audioStarted = false;
        let synth, bassSynth, noiseSynth, padSynth, bgNoiseSynth;

        async function initAudio() {
            if (audioStarted || !CONFIG.audio.enabled) return;
            
            const cfg = CONFIG.audio;
            
            try {
                await Tone.start();
                audioStarted = true;

                synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }
                }).toDestination();
                synth.volume.value = cfg.synthVolume;

                bassSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 3,
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.3 }
                }).toDestination();
                bassSynth.volume.value = cfg.bassVolume;

                noiseSynth = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.005, decay: 0.15, sustain: 0 }
                }).toDestination();
                noiseSynth.volume.value = cfg.noiseVolume;

                bgNoiseSynth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.005, decay: 0.06, sustain: 0 }
                }).toDestination();
                bgNoiseSynth.volume.value = cfg.bgNoiseVolume;

                const reverb = new Tone.Reverb({ decay: 6, wet: 0.5 }).toDestination();
                padSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'sine' },
                    envelope: { attack: 3, decay: 1, sustain: 0.5, release: 4 }
                }).connect(reverb);
                padSynth.volume.value = cfg.padVolume;

                const chords = [
                    ['C3', 'E3', 'G3', 'B3'],
                    ['A2', 'C3', 'E3', 'G3'],
                    ['F2', 'A2', 'C3', 'E3'],
                    ['G2', 'B2', 'D3', 'F3']
                ];
                let chordIdx = 0;

                const playChord = () => {
                    if (!audioStarted) return;
                    padSynth.triggerAttackRelease(chords[chordIdx], '1n');
                    chordIdx = (chordIdx + 1) % chords.length;
                };

                playChord();
                setInterval(playChord, cfg.chordInterval);

            } catch (e) {
                console.log('Audio init failed:', e);
            }
        }

        function playLaunchSound() {
            if (!audioStarted || !CONFIG.audio.enabled) return;
            try {
                synth.triggerAttackRelease('C2', '16n');
                noiseSynth.triggerAttackRelease('32n');
            } catch (e) {}
        }

        function playExplosionSound() {
            if (!audioStarted || !CONFIG.audio.enabled) return;
            try {
                const chords = [['C5', 'E5', 'G5'], ['D5', 'F5', 'A5'], ['E5', 'G5', 'B5']];
                synth.triggerAttackRelease(chords[Math.floor(Math.random() * chords.length)], '8n');
                bassSynth.triggerAttackRelease('C2', '8n');
                noiseSynth.triggerAttackRelease('8n');
            } catch (e) {}
        }

        function playBgExplosion() {
            if (!audioStarted || !CONFIG.audio.enabled) return;
            try {
                bgNoiseSynth.triggerAttackRelease('16n');
            } catch (e) {}
        }

        function playFormSound() {
            if (!audioStarted || !CONFIG.audio.enabled) return;
            try {
                synth.triggerAttackRelease(['E4', 'G4', 'B4'], '4n');
            } catch (e) {}
        }

        // ==================== ANIMATION LOOP ====================
        function checkAllFormed() {
            const currentParticles = particles.filter(p => p.messageId === currentMessageId);
            if (currentParticles.length === 0) return false;
            return currentParticles.every(p => p.phase === 'hold' || p.phase === 'fade');
        }

        function checkAllHolding() {
            const currentParticles = particles.filter(p => p.messageId === currentMessageId);
            if (currentParticles.length === 0) return false;
            return currentParticles.every(p => p.phase === 'hold');
        }

        function animate() {
            fCtx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);

            // Update rockets
            rockets.forEach(rocket => {
                rocket.update();
                rocket.draw();
                
                if (rocket.exploded && !rocket.particlesCreated) {
                    rocket.particlesCreated = true;
                    createParticles(rocket);
                }
            });
            rockets = rockets.filter(r => !r.exploded);

            // Update particles
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Play form sound
            if (!formSoundPlayed && checkAllFormed() && particles.length > 0) {
                formSoundPlayed = true;
                setTimeout(playFormSound, CONFIG.delays.formSoundDelay);
            }

            // Trigger next message
            if (isShowingMessage && !canLaunchNext && !isLaunching && checkAllHolding()) {
                holdFrameCount++;
                
                if (holdFrameCount >= CONFIG.delays.triggerNextAfterHoldFrames) {
                    canLaunchNext = true;
                    proceedToNextMessage();
                }
            }

            // Cleanup particles
            particles = particles.filter(p => p.alpha > 0 || p.isFinal);

            requestAnimationFrame(animate);
        }

        // ==================== START ====================
        async function start() {
            await initAudio();
            
            console.log(`Starting fireworks with ${CONFIG.messages.length} messages`);
            updateProgress(0, CONFIG.messages.length);
            
            setTimeout(() => {
                launchFireworks(CONFIG.messages[0], CONFIG.messages.length === 1);
            }, CONFIG.delays.startDelay);
        }

        animateStars();
        animateBgFireworks();
        animate();

        document.addEventListener('DOMContentLoaded', start);
        document.body.addEventListener('touchstart', initAudio, { once: true });
        document.body.addEventListener('click', initAudio, { once: true });
    </script>
</body>
</html>
